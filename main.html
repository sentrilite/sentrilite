<!--
Copyright (c) 2025 Sentrilite, Inc. All rights reserved.

This software is the confidential and proprietary information of
Sentrilite ("Confidential Information"). You shall not
disclose such Confidential Information and shall use it only
in accordance with the terms of the license agreement you entered
into with Sentrilite.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sentrilite Main Dashboard</title>
  <!-- script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script -->
</head>
<style>
  :root {
    --primary: #00ff99;
    --secondary: #00bfff;
    --bg: #000000;
    --card-bg: #101a2b;
    --text: #e6f1ff;
    --muted: #a8b2d1;
    --border: rgba(0, 255, 153, 0.15);
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    margin: 0;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    line-height: 1.5;
  }

  header {
    background: linear-gradient(90deg, #000 70%, #00bfff22 100%);
    padding: 1.25rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--border);
    position: sticky;
    top: 0;
    z-index: 10;
  }

  header span {
    font-size: 1.75rem;
    font-weight: 700;
    background: linear-gradient(90deg, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 0 15px rgba(0, 255, 153, 0.3);
  }

  button {
    background: var(--card-bg);
    color: var(--text);
    border: 1px solid var(--border);
    padding: 0.625rem 1.25rem;
    border-radius: 0.375rem;
    font-weight: 500;
    font-size: 0.875rem;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  button:hover {
    border-color: var(--primary);
    box-shadow: 0 0 10px rgba(0, 255, 153, 0.2);
  }

  .primary-button {
    background: linear-gradient(90deg, var(--primary), var(--secondary));
    color: var(--bg);
    border: none;
    font-weight: 600;
  }

  .primary-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 0 15px rgba(0, 255, 153, 0.3);
  }

  #upload-section {
    background: linear-gradient(120deg, #000 60%, #00bfff11 100%);
    padding: 1rem;
    border-bottom: 1px solid var(--border);
    position: relative;
  }

  .container {
    display: flex;
    flex: 1;
    background: linear-gradient(120deg, #000 60%, #00bfff11 100%);
  }

  aside {
    width: 280px;
    background: var(--card-bg);
    border-right: 1px solid var(--border);
    padding: 1.5rem;
  }

  .rule-box {
    margin-bottom: 2rem;
  }

  .rule-box h3 {
    color: var(--primary);
    margin-bottom: 1rem;
    font-size: 1.1rem;
  }

  /* Rules display styles */
  .rules-container {
    max-height: 300px;
    overflow-y: auto;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    padding: 0.5rem;
    margin-top: 0.5rem;
  }

  .rule-item {
    background: rgba(0, 255, 153, 0.05);
    border: 1px solid var(--border);
    border-radius: 0.25rem;
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    font-size: 0.8rem;
  }

  .rule-item:last-child {
    margin-bottom: 0;
  }

  .rule-type {
    color: var(--primary);
    font-weight: bold;
    margin-bottom: 0.25rem;
  }

  .rule-details {
    color: var(--muted);
    font-size: 0.75rem;
  }

  .no-rules {
    color: var(--muted);
    text-align: center;
    font-style: italic;
    padding: 1rem;
  }

  .loading-rules {
    color: var(--secondary);
    text-align: center;
    padding: 1rem;
  }

  input[type="text"],
  input[type="number"] {
    width: 100%;
    padding: 0.625rem;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    color: var(--text);
    margin-bottom: 0.75rem;
    font-size: 0.875rem;
    transition: all 0.2s ease;
  }

  input[type="text"]:focus,
  input[type="number"]:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 10px rgba(0, 255, 153, 0.1);
  }

  main {
    flex: 1;
    padding: 1.5rem;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    background: var(--card-bg);
    margin-top: 1rem;
    border-radius: 0.5rem;
    overflow: hidden;
  }

  th {
    background: rgba(0, 255, 153, 0.05);
    padding: 0.75rem;
    font-weight: 600;
    text-align: center;
    border: 1px solid var(--border);
    color: var(--primary);
  }

  td {
    padding: 0.75rem;
    text-align: center;
    border: 1px solid var(--border);
    vertical-align: middle;
  }

  tr:hover {
    background: rgba(0, 255, 153, 0.02);
  }

  .online { 
    color: var(--primary); 
    font-weight: bold;
  }

  .offline { 
    color: #e74c3c; 
    font-weight: bold;
  }

  .critical { 
    color: #f39c12; 
    font-weight: bold;
  }

  .none { 
    color: var(--muted);
  }

  #insight-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-bg);
    padding: 2rem;
    border-radius: 0.5rem;
    border: 1px solid var(--border);
    max-width: 600px;
    width: 90%;
    display: none;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
  }

  #rules-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-bg);
    padding: 2rem;
    border-radius: 0.5rem;
    border: 1px solid var(--border);
    max-width: 800px;
    width: 90%;
    max-height: 80vh;
    display: none;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    overflow-y: auto;
  }

  #rules-popup h3 {
    color: var(--primary);
    margin-bottom: 1rem;
    border-bottom: 1px solid var(--border);
    padding-bottom: 0.5rem;
  }

  #rules-content {
    max-height: 60vh;
    overflow-y: auto;
    margin: 1rem 0;
    color: var(--muted);
    line-height: 1.6;
  }

  a {
    color: var(--secondary);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.2s ease;
  }

  a:hover {
    color: var(--primary);
  }

  footer {
    background: var(--card-bg);
    padding: 1rem;
    text-align: center;
    color: var(--muted);
    border-top: 1px solid var(--border);
  }

  /* Checkbox styling */
  input[type="checkbox"] {
    accent-color: var(--primary);
  }

  /* Radio button styling */
  input[type="radio"] {
    accent-color: var(--primary);
  }

  /* Mobile Responsiveness */
  @media (max-width: 1024px) {
    .container {
      flex-direction: column;
    }
    
    aside {
      width: 100%;
      border-right: none;
      border-bottom: 1px solid var(--border);
    }
  }

  @media (max-width: 768px) {
    header {
      padding: 1rem;
      flex-wrap: wrap;
      gap: 0.75rem;
    }
    
    header span {
      font-size: 1.25rem;
    }
    
    main {
      padding: 1rem;
    }
    
    th, td {
      padding: 0.5rem;
      font-size: 0.875rem;
    }
  }
</style>
<body>
<header>
  <span>Sentrilite: Real-Time Multi-Cloud Observability & Security</span>
<button onclick="downloadHumanReport()" style="
  font-size: 1.0rem;
  padding: 4px 6px;
  background: linear-gradient(90deg, #00cc7a, #0099cc);
  color: #ffffff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  margin-left: 30em;
  font-weight: 500;
  box-shadow: 0 2px 8px rgba(0, 255, 153, 0.15);
">
  üìÑ Download PDF Report
</button>

<a href="#" id="download-link" style="font-size: 15px;" onclick="generateCombinedAlerts(); return false;">
  üìÅ Download Combined Alerts (JSON)
</a>

</header>

<div id="upload-section" style="position: relative; margin-bottom: 10px;">

  <!-- Centered upload controls -->
  <div style="text-align: center;">
    <input type="file" id="serverFile" accept=".txt" />
    <button onclick="uploadServers()">Upload Node List</button>
    <button onclick="exportDashboard()">Download Dashboard</button>
    <label style="margin-left: 1em;">
      <input type="checkbox" id="checkAll" onchange="toggleAllServers(this)">
      Select All
    </label>
  </div>

  <!-- Absolutely positioned right-aligned link -->
  <a href="#" onclick="clearAllCriticalAlerts(); return false;"
     style="position: absolute; top: 0; right: 0; font-size: 15px; text-decoration: underline; color: #c00;">
    üßπ Clear All Alerts
  </a>
</div>

</div>

<div class="container">
  <aside>
    <div class="rule-box">
      <h3>‚õ® Create Rule</h3>
      <input id="edr-key" placeholder="match_key (e.g. cmd)" />
      <input id="edr-values" placeholder="match_values (comma separated)" />
      <input id="edr-tags" placeholder="tags (comma separated)" />
      <input id="edr-risk" type="number" min="1" max="3" placeholder="risk level" />
      <input id="edr-tag-filter" placeholder="server_tag (default: all)" />
      <button onclick="applyEDRRule()">Apply to Selected</button>
    </div>
    <div class="rule-box">
      <h3>üß† View Rules</h3>
      <button onclick="viewAllRules()" style="width: 100%;">View All Rules</button>
    </div>
    <div class="rule-box">
      <h3>üóëÔ∏è Delete Rules</h3>
      <button onclick="deleteAllRules()" style="width: 100%;">Delete All Rules</button>
    </div>
    <div class="rule-box">
      <h3>üõ°Ô∏è Network Rule</h3>
      <label><input type="radio" name="xdr-action" value="block" checked /> Block</label>
      <label><input type="radio" name="xdr-action" value="allow" /> Allow</label>
      <input id="xdr-ip" placeholder="IP Address (optional)" />
      <input id="xdr-port" placeholder="Port or Range (e.g. 80 or 1000-2000)" />
      <input id="xdr-tag-filter" placeholder="server_tag (default: all)" />
      <button onclick="applyXDRRule()">Apply to Selected</button>
    </div>
    <div class="rule-box">
      <h3>üß† View Network Rules</h3>
      <button onclick="viewAllXDRRules()" style="width: 100%;">View All Network Rules</button>
    </div>
    <div class="rule-box">
      <h3>üóëÔ∏è Delete Network Rules</h3>
      <button onclick="deleteAllXDRRules()" style="width: 100%;">Delete All Network Rules</button>
    </div>
  </aside>

  <main>
    <table>
      <thead>
        <tr>
          <th>Select</th>
          <th>Server IP</th>
          <th>Status</th>
          <th>Alerts</th>
          <th>Groups</th>
          <th>Dashboard</th>
          <th>AI Insights</th>
        </tr>
      </thead>
      <tbody id="serverTableBody"></tbody>
    </table>
  </main>
</div>

<footer>
  ¬© 2025 Sentrilite Inc. All rights reserved. Contact: info@Sentrilite.com
</footer>

<div id="insight-popup">
  <h3>üîç LLM Insight</h3>
  <div id="insight-content"></div>
  <button onclick="document.getElementById('insight-popup').style.display='none'">‚ùå Close</button>
</div>

<div id="rules-popup">
  <h3>üß† All Rules</h3>
  <div id="rules-content"></div>
  <button onclick="closeRulesPopup()">‚ùå Close</button>
</div>
<script src="jspdf.umd.min.js"></script>
<script>window.jsPDF = window.jspdf.jsPDF;</script>
<script>
const insightsCache = {};   // üß† { ip: { text: "...", timestamp: 123456 } }
const alertsSnapshot = {};  // üß† { ip: "alerts-stringified" }

function toggleAllServers(checkbox) {
  document.querySelectorAll(".select-server").forEach(cb => cb.checked = checkbox.checked);
}

function uploadServers() {
  const file = document.getElementById('serverFile').files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    const lines = reader.result.split('\n').map(line => line.trim()).filter(Boolean);
    const tbody = document.getElementById("serverTableBody");
    tbody.innerHTML = "";

    lines.forEach(line => {
      const [ip, group = ""] = line.split(',').map(x => x.trim());
      const row = document.createElement("tr");
      row.innerHTML = `
        <td><input type="checkbox" class="select-server" data-ip="${ip}" /></td>
        <td>${ip}</td>
        <td id="status-${ip}">‚è≥</td>
        <td id="alert-${ip}">‚è≥</td>
        <td contenteditable="true" id="group-${ip}">${group}</td>
        <td><a href="http://${ip}/dashboard.html" target="_blank">Open</a></td>
        <td>
          <a href="#" onclick="showInsight('${ip}')" id="insight-link-${ip}">View</a> |
          <a href="#" onclick="refreshInsightManually('${ip}')" style="color: #00c3ff;">üîÑ</a>
        </td>
      `;
      tbody.appendChild(row);
    });

    refreshAll();
    setInterval(refreshAll, 5000); // ‚è≤Ô∏è Re-check health every 5 seconds
  };
  reader.readAsText(file);
}

function refreshAll() {
  document.querySelectorAll(".select-server").forEach(cb => {
    const ip = cb.dataset.ip;
    const ws = new WebSocket(`ws://${ip}:8765`);
    let isHealthy = false;

    ws.onopen = () => {
      ws.send(JSON.stringify({ type: "health" }));
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);

        if (data.type === "health") {
          isHealthy = true;
          document.getElementById(`status-${ip}`).innerHTML = `<span class="online">Online</span>`;

          const alertText = (data.alert_status === "Critical")
            ? `<a href="#" onclick="showAlertsPopup('${ip}'); return false;" style="color: #f39c12; font-weight: bold; text-decoration: underline;">Critical</a>`
            : `<span class="none">None</span>`;
          document.getElementById(`alert-${ip}`).innerHTML = alertText;

          // Remove automatic LLM fetching - only fetch when user clicks "View"
          if (data.alert_status !== "Critical") {
            delete insightsCache[ip]; // No critical alerts, remove old insight
          }
        }
      } catch (err) {
        console.error("WebSocket parsing error:", err);
      } finally {
        ws.close(); // ‚úÖ Close only after finished parsing
      }
    };

    ws.onerror = () => {
      document.getElementById(`status-${ip}`).innerHTML = `<span class="offline">Unreachable</span>`;
      document.getElementById(`alert-${ip}`).innerHTML = `<span class="none">Unknown</span>`;
    };

    ws.onclose = () => {
      if (!isHealthy) { // ‚úÖ Only mark offline if never got a good message
        document.getElementById(`status-${ip}`).innerHTML = `<span class="offline">Unreachable</span>`;
        document.getElementById(`alert-${ip}`).innerHTML = `<span class="none">Unknown</span>`;
      }
    };
  });
}

function fetchAlertsAndInsights(ip, force = false) {
  const ws = new WebSocket(`ws://${ip}:8765`);

  ws.onopen = () => {
    ws.send(JSON.stringify({ type: "get_alerts" }));
  };

  ws.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);

      if (data.type === "alert_list" && Array.isArray(data.alerts)) {
        const newSnapshot = JSON.stringify(data.alerts);

        if (!force && alertsSnapshot[ip] === newSnapshot) {
          console.log(`‚ÑπÔ∏è No change in alerts for ${ip}. Skipping LLM refresh.`);
          ws.close();
          return;
        }

        alertsSnapshot[ip] = newSnapshot; // üì¶ Save new alerts snapshot

        const alertText = data.alerts.map(a => `[${a.time}] ${a.message}`).join("\n");

        const prompt = `### Instruction:\nYou are a cybersecurity expert. Summarize and assess the following alerts for server ${ip}. Indicate severity and suggest remediation.\n\n### Input:\n${alertText}\n\n### Response:\n`;

        fetch('http://ec2-3-144-169-112.us-east-2.compute.amazonaws.com:3000/completion', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: prompt,
            n_predict: 512,
            temperature: 0.2,
            stream: false
          })
        })
        .then(res => res.json())
        .then(data => {
          if (data.content) {
            insightsCache[ip] = { text: data.content, timestamp: Date.now() };
            console.log(`‚úÖ Insight updated for ${ip}`);
            
            // Update the popup content if it's currently open for this IP
            const popup = document.getElementById("insight-popup");
            if (popup.style.display === "block") {
              const contentDiv = document.getElementById("insight-content");
              contentDiv.innerHTML = `
                <div style="margin-bottom: 1em;">${data.content}</div>
                <button onclick="refreshInsightManually('${ip}')" style="background: var(--highlight); color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer;">üîÑ Refresh Insight</button>
              `;
            }
          } else {
            console.error("‚ö†Ô∏è LLM server returned no content");
            // Update popup with error message
            const popup = document.getElementById("insight-popup");
            if (popup.style.display === "block") {
              const contentDiv = document.getElementById("insight-content");
              contentDiv.innerHTML = `
                <div style="color: #e74c3c; margin-bottom: 1em;">‚ùå Failed to generate AI insights. Please try again.</div>
                <button onclick="refreshInsightManually('${ip}')" style="background: var(--highlight); color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer;">üîÑ Retry</button>
              `;
            }
          }
        })
        .catch(err => {
          console.error("‚ùå LLM fetch error:", err);
          // Update popup with error message
          const popup = document.getElementById("insight-popup");
          if (popup.style.display === "block") {
            const contentDiv = document.getElementById("insight-content");
            contentDiv.innerHTML = `
              <div style="color: #e74c3c; margin-bottom: 1em;">‚ùå Failed to generate AI insights: ${err.message}</div>
              <button onclick="refreshInsightManually('${ip}')" style="background: var(--highlight); color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer;">üîÑ Retry</button>
            `;
          }
        });
      }
    } catch (err) {
      console.error("WebSocket alert fetch error:", err);
    } finally {
      ws.close(); // ‚úÖ Always close after processing
    }
  };

  ws.onerror = (err) => {
    console.error(`‚ùå WebSocket error fetching alerts from ${ip}:`, err);
  };
}

function showInsight(ip) {
  // Check if we have cached insights
  const cachedInsight = insightsCache[ip];
  
  if (cachedInsight) {
    // Show cached insight immediately
    const contentDiv = document.getElementById("insight-content");
    contentDiv.innerHTML = `
      <div style="margin-bottom: 1em;">${cachedInsight.text}</div>
      <button onclick="refreshInsightManually('${ip}')" style="background: var(--highlight); color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer;">üîÑ Refresh Insight</button>
    `;
    document.getElementById("insight-popup").style.display = "block";
  } else {
    // Show loading and fetch fresh insights
    const contentDiv = document.getElementById("insight-content");
    contentDiv.innerHTML = '<div style="text-align: center; padding: 2rem;">üîÑ Generating AI insights...</div>';
    document.getElementById("insight-popup").style.display = "block";
    
    // Fetch alerts and generate insights
    fetchAlertsAndInsights(ip, true);
  }
}

function refreshInsightManually(ip) {
  fetchAlertsAndInsights(ip, true); // üî• Always force refresh
}

function applyRule(rule, tagFilter, isXDR = false) {
  const allServers = Array.from(document.querySelectorAll(".select-server"));
  const tag = (tagFilter || "").trim().toUpperCase();

  const targets = allServers.filter(cb => {
    const ip = cb.dataset.ip;
    const cell = document.getElementById(`group-${ip}`);
    const groupText = cell?.textContent || "";
    const groupTags = groupText.split(',').map(t => t.trim().toUpperCase()).filter(Boolean);
    const matchesGroup = !tag || groupTags.includes(tag);
    return cb.checked || matchesGroup;
  }).map(cb => cb.dataset.ip);

  if (!targets.length) {
    const selectedGroups = allServers.map(cb => {
      const ip = cb.dataset.ip;
      const cell = document.getElementById(`group-${ip}`);
      return `IP=${ip}, Group=${cell?.textContent.trim() || '(none)'}`;
    });
    console.log(`No matching servers for ${isXDR ? 'XDR' : 'EDR'} Rule. Groups:`);
    selectedGroups.forEach(g => console.log(g));
    return;
  }

  alert(`üìã Dispatching rule to servers: ${targets.join(', ')}`);

  targets.forEach(ip => {
    const ws = new WebSocket(`ws://${ip}:8765`);
    ws.onopen = () => {
      ws.send(JSON.stringify(rule));
      ws.close();
    };
  });

  alert(`‚úÖ ${isXDR ? 'XDR' : 'EDR'} Rule dispatched to ${targets.length} server(s).`);
}

function applyEDRRule() {
  const key = document.getElementById("edr-key").value.trim();
  const values = document.getElementById("edr-values").value.split(",").map(v => v.trim()).filter(Boolean);
  const tags = document.getElementById("edr-tags").value.split(",").map(v => v.trim()).filter(Boolean);
  const risk = parseInt(document.getElementById("edr-risk").value);
  const tagFilter = document.getElementById("edr-tag-filter").value.trim();

  if (!key || !values.length || ![1, 2, 3].includes(risk)) {
    return alert("‚ùå Please provide valid EDR rule parameters.");
  }

  const rule = {
    type: "add_rule",
    match_key: key,
    match_values: values,
    tags: tags,
    risk_level: risk
  };

  applyRule(rule, tagFilter);
}

function applyXDRRule() {
  const action = document.querySelector('input[name="xdr-action"]:checked').value;
  const ipVal = document.getElementById("xdr-ip").value.trim();
  const port = document.getElementById("xdr-port").value.trim();
  const tagFilter = document.getElementById("xdr-tag-filter").value.trim();

  if (!ipVal && !port) return alert("Please specify at least IP or Port.");

  const rule = {
    type: "add_xdr_rule",
    rule_type: action,
    value: { ip: ipVal, port }
  };

  applyRule(rule, tagFilter, true);
}

function exportDashboard() {
  const rows = document.querySelectorAll("#serverTableBody tr");
  const lines = [];

  rows.forEach(row => {
    const ip = row.querySelector(".select-server")?.dataset.ip;
    const group = document.getElementById(`group-${ip}`)?.textContent.trim();
    lines.push(`${ip}${group ? ',' + group : ''}`);
  });

  const blob = new Blob([lines.join('\n')], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "dashboard_export.txt";
  a.click();
  URL.revokeObjectURL(url);
}

// IMPROVED: Better error handling and debugging for PDF generation
async function downloadHumanReport() {
  console.log("üöÄ Starting PDF generation...");
  console.log("üìã Current insights cache:", insightsCache);
  console.log("üìã Current alerts snapshot:", alertsSnapshot);
  
  const doc = new jsPDF();
  const now = new Date().toLocaleString();
  let y = 15;

  doc.setFontSize(18);
  doc.setTextColor(40, 40, 40);
  doc.text("Sentrilite Alert Summary Report", 10, y);
  y += 8;

  doc.setFontSize(10);
  doc.setTextColor(100, 100, 100);
  doc.text(`Generated on: ${now}`, 10, y);
  y += 10;

  const rows = Array.from(document.querySelectorAll(".select-server"));
  console.log(`üìä Found ${rows.length} servers in table`);
  
  if (rows.length === 0) {
    console.error("‚ùå No servers found! Make sure you've uploaded a server list.");
    alert("No servers found! Please upload a server list first.");
    return;
  }

  console.log("üîç Server IPs found:", rows.map(row => row.dataset.ip));

  const alertResults = await Promise.all(rows.map(async row => {
    const ip = row.dataset.ip;
    console.log(`\nüîç Starting fetch for ${ip}...`);
    try {
      // Force fresh fetch for PDF generation - bypass cache
      const alerts = await fetchAlertsFromServer(ip, 5000, true); // Added force=true parameter
      console.log(`‚úÖ ${ip}: Got ${alerts.length} alerts`);
      console.log(`üìã ${ip}: Alert data:`, alerts);
      return { ip, alerts, success: true };
    } catch (err) {
      console.error(`‚ùå ${ip}: Failed to fetch alerts:`, err);
      return { ip, alerts: [], success: false };
    }
  }));

  console.log("\nüìä All alert results:", alertResults);

  let totalAlerts = 0;
  let serversProcessed = 0;
  
  for (const row of rows) {
    const ip = row.dataset.ip;
    console.log(`\nüìù Processing server: ${ip}`);
    
    const group = document.getElementById(`group-${ip}`)?.textContent.trim() || "unknown";
    const insight = insightsCache[ip]?.text || "No AI insight available.";
    const result = alertResults.find(r => r.ip === ip);
    
    console.log(`üìã Group for ${ip}:`, group);
    console.log(`üìã Insight for ${ip}:`, insight);
    console.log(`üìã Result for ${ip}:`, result);
    
    if (!result || !result.success) {
      console.warn(`‚ö†Ô∏è Skipping ${ip} - no data available`);
      continue;
    }

    const alerts = result.alerts;
    console.log(`üìã Raw alerts for ${ip}:`, alerts);
    console.log(`üìã Alerts type:`, typeof alerts);
    console.log(`üìã Alerts length:`, alerts.length);
    console.log(`üìã Is array:`, Array.isArray(alerts));
    
    totalAlerts += alerts.length;
    serversProcessed++;
    console.log(`üìù Adding ${ip} to PDF with ${alerts.length} alerts`);

    // Server Header
    doc.setFillColor(220, 230, 250);
    doc.setDrawColor(180, 180, 180);
    doc.rect(10, y - 5, 190, 10, 'FD');
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.setTextColor(33, 33, 33);
    doc.text(`Server: ${ip}   |   Group: ${group}`, 12, y);
    y += 12;

    // Table Headers
    doc.setFontSize(10);
    doc.setFont(undefined, 'bold');
    doc.setFillColor(240, 240, 240);
    doc.rect(12, y - 4, 186, 8, 'F');
    doc.text("Timestamp", 14, y);
    doc.text("Message", 60, y);
    y += 6;

    doc.setFont(undefined, 'normal');

    if (alerts.length > 0) {
      console.log(`üìã Processing ${alerts.length} alerts for ${ip}`);
      for (let i = 0; i < alerts.length; i++) {
        const a = alerts[i];
        console.log(`üìã Alert ${i + 1} from ${ip}:`, a);
        
        const ts = a.time || a.timestamp || a.created_at || "Unknown time";
        const msg = a.message || a.msg || a.description || "Unknown event";
        const risk = a.risk_level || a.severity || "unknown";
        const color = getRiskColor(risk);
    
        console.log(`üìã Processed alert ${i + 1}:`, { ts, msg, risk, color });
    
        const splitMsg = doc.splitTextToSize(msg, 130);
    
        // Timestamp (always black)
        doc.setTextColor(0, 0, 0);
        doc.text(ts, 14, y);
    
        // Message (color-coded)
        doc.setTextColor(...color);
        doc.text(splitMsg, 60, y);
    
        y += (splitMsg.length * 6);
    
        if (y > 270) {
          doc.addPage();
          y = 15;
        }
      }
    } else {
      console.log(`üìã No alerts found for ${ip}`);
      doc.setTextColor(150, 150, 150);
      doc.text("No alerts found.", 14, y);
      y += 6;
    }

    // AI Insight Box
    y += 4;
    const insightText = doc.splitTextToSize(insight, 170);
    doc.setFillColor(245, 245, 245);
    doc.setDrawColor(220, 220, 220);
    doc.rect(12, y, 180, insightText.length * 6 + 8, 'FD');
    doc.setFont(undefined, 'italic');
    doc.setTextColor(80, 80, 80);
    doc.text("AI Insight:", 14, y + 6);
    doc.setFont(undefined, 'normal');
    doc.setTextColor(60, 60, 60);
    doc.text(insightText, 14, y + 12);
    y += insightText.length * 6 + 12;

    if (y > 270) {
      doc.addPage();
      y = 15;
    }
  }

  console.log(`\n‚úÖ PDF generation complete:`);
  console.log(`üìä Servers processed: ${serversProcessed}`);
  console.log(`üìä Total alerts: ${totalAlerts}`);
  console.log(`üìä Servers with alerts: ${alertResults.filter(r => r.success && r.alerts.length > 0).length}`);
  
  if (totalAlerts === 0) {
    console.warn("‚ö†Ô∏è WARNING: No alerts were found for any server!");
    alert("No alerts found for any server. Check the console for details.");
  }
  
  doc.save("Sentrilite_Report.pdf");
}

// IMPROVED: Better error handling and debugging for fetching alerts
async function fetchAlertsFromServer(ip, timeoutMs = 10000, force = false) {
  return new Promise((resolve, reject) => {
    const ws = new WebSocket(`ws://${ip}:8765`);
    let resolved = false;
    let responseReceived = false;
    let responseData = null;

    const timeout = setTimeout(() => {
      if (!resolved) {
        resolved = true;
        ws.close();
        console.warn(`‚è∞ Timeout (${timeoutMs}ms) fetching alerts from ${ip}`);
        resolve([]); // Return empty array instead of rejecting
      }
    }, timeoutMs);

    ws.onopen = () => {
      console.log(`üîó WebSocket opened to ${ip}${force ? ' (forced refresh)' : ''}`);
      console.log(`üì§ Sending get_alerts request to ${ip}`);
      ws.send(JSON.stringify({ type: "get_alerts" }));
    };

    ws.onmessage = (event) => {
      responseReceived = true;
      responseData = event.data;
      console.log(`üì• Raw response from ${ip}:`, event.data);
      
      try {
        const data = JSON.parse(event.data);
        console.log(`üìã Parsed response from ${ip}:`, data);
        
        if (data.type === "alert_list" && Array.isArray(data.alerts)) {
          console.log(`‚úÖ Got ${data.alerts.length} alerts from ${ip}`);
          clearTimeout(timeout);
          resolved = true;
          resolve(data.alerts);
        } else if (data.type === "alert_list" && !Array.isArray(data.alerts)) {
          console.warn(`‚ö†Ô∏è No alerts array from ${ip}:`, data);
          clearTimeout(timeout);
          resolved = true;
          resolve([]);
        } else {
          console.warn(`‚ö†Ô∏è Unexpected response type from ${ip}:`, data.type);
          console.warn(`üìã Full response:`, data);
          clearTimeout(timeout);
          resolved = true;
          resolve([]);
        }
      } catch (err) {
        console.error(`‚ùå JSON parse error from ${ip}:`, err);
        console.error(`üì• Raw data that failed to parse:`, event.data);
        clearTimeout(timeout);
        resolved = true;
        resolve([]);
      }
    };

    ws.onerror = (err) => {
      console.error(`‚ùå WebSocket error from ${ip}:`, err);
      if (!resolved) {
        clearTimeout(timeout);
        resolved = true;
        resolve([]);
      }
    };

    ws.onclose = (event) => {
      console.log(`üîå WebSocket closed for ${ip}. Code: ${event.code}, Reason: ${event.reason}, Clean: ${event.wasClean}`);
      
      // If we received a response but haven't resolved yet, try to process it
      if (!resolved && responseReceived && responseData) {
        console.log(`üîÑ Processing response after connection close for ${ip}`);
        try {
          const data = JSON.parse(responseData);
          console.log(`üìã Processing delayed response from ${ip}:`, data);
          
          if (data.type === "alert_list" && Array.isArray(data.alerts)) {
            console.log(`‚úÖ Got ${data.alerts.length} alerts from ${ip} (delayed processing)`);
            clearTimeout(timeout);
            resolved = true;
            resolve(data.alerts);
            return;
          }
        } catch (err) {
          console.error(`‚ùå Failed to process delayed response from ${ip}:`, err);
        }
      }
      
      if (!resolved) {
        if (!responseReceived) {
          console.warn(`‚ö†Ô∏è WebSocket closed for ${ip} before any response received`);
        } else {
          console.warn(`‚ö†Ô∏è WebSocket closed for ${ip} after response but before resolution`);
        }
        clearTimeout(timeout);
        resolved = true;
        resolve([]);
      }
    };
  });
}

function getRiskColor(level) {
  const risk = String(level || "").toLowerCase();
  switch (risk) {
    case "critical":
    case "high":
    case "1": return [200, 0, 0];       // üî¥ Red
    case "medium":
    case "2": return [255, 140, 0];     // üü† Orange
    case "low":
    case "3": return [0, 128, 0];       // üü¢ Green
    default: return [120, 120, 120];    // ‚ö´ Gray
  }
}

function getRiskBullet(level) {
  const risk = String(level || "").toLowerCase();
  switch (risk) {
    case "critical":
    case "high":
    case "1": return "üî¥";
    case "medium":
    case "2": return "üü†";
    case "low":
    case "3": return "üü¢";
    default: return "‚ö´";
  }
}

async function generateCombinedAlerts() {
  const rows = document.querySelectorAll(".select-server");
  const combinedAlerts = [];

  await Promise.all(Array.from(rows).map(async row => {
    const ip = row.dataset.ip;
    try {
      const alerts = await fetchAlertsFromServer(ip, 3000);
      alerts.forEach(a => combinedAlerts.push({ server: ip, ...a }));
    } catch (err) {
      console.warn(`Skipping unreachable server: ${ip}`);
    }
  }));

  const blob = new Blob([JSON.stringify(combinedAlerts, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const download = document.createElement("a");
  download.href = url;
  download.download = "combined_alerts.json";
  download.style.display = "none";
  document.body.appendChild(download);
  download.click();
  document.body.removeChild(download);
  URL.revokeObjectURL(url);
}

function clearAllCriticalAlerts() {
  const rows = document.querySelectorAll(".select-server");
  let clearedCount = 0;
  let totalAttempts = 0;
  let completedAttempts = 0;

  rows.forEach(row => {
    const ip = row.dataset.ip;
    const alertCell = document.getElementById(`alert-${ip}`);
    const isCritical = alertCell?.textContent.includes("Critical");

    if (isCritical) {
      totalAttempts++;
      console.log(`üîÑ Attempting to clear alerts from ${ip}...`);
      
      const ws = new WebSocket(`ws://${ip}:8765`);
      let responseReceived = false;
      let timeoutId = null;
      
      // Set a timeout for the entire operation
      timeoutId = setTimeout(() => {
        console.warn(`‚è∞ Timeout waiting for response from ${ip}`);
        if (!responseReceived) {
          ws.close();
        }
      }, 10000); // 10 second timeout
      
      ws.onopen = () => {
        console.log(`‚úÖ Connected to ${ip}, sending clear_alerts request`);
        ws.send(JSON.stringify({ type: "clear_alerts" }));
      };
      
      ws.onmessage = (event) => {
        console.log(`üì• Raw response from ${ip}:`, event.data);
        responseReceived = true;
        
        // Clear the timeout since we got a response
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        
        try {
          const data = JSON.parse(event.data);
          console.log(`üìã Parsed response from ${ip}:`, data);
          
          if (data.type === "clear_alerts_ack") {
            clearedCount++;
            console.log(`‚úÖ Alerts cleared from ${ip}`);
            // Update the alert status in the UI
            document.getElementById(`alert-${ip}`).innerHTML = `<span class="none">None</span>`;
          } else {
            console.warn(`‚ö†Ô∏è Unexpected response type from ${ip}:`, data.type);
          }
        } catch (err) {
          console.error(`‚ùå Failed to parse response from ${ip}:`, err);
          console.error(`üì• Raw data that failed to parse:`, event.data);
        }
        
        // Add a small delay before closing to ensure response is processed
        setTimeout(() => {
          ws.close();
        }, 100);
      };
      
      ws.onerror = (err) => {
        console.error(`‚ùå WebSocket error for ${ip}:`, err);
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        completedAttempts++;
        checkCompletion();
      };
      
      ws.onclose = (event) => {
        console.log(`üîå WebSocket closed for ${ip}. Code: ${event.code}, Reason: ${event.reason}, Clean: ${event.wasClean}`);
        
        // Clear timeout if it's still active
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        
        if (!responseReceived) {
          console.warn(`‚ö†Ô∏è No response received from ${ip} before connection closed`);
        }
        
        completedAttempts++;
        checkCompletion();
      };
    }
  });

  function checkCompletion() {
    console.log(`üìä Progress: ${completedAttempts}/${totalAttempts} attempts completed, ${clearedCount} successful`);
    
    if (completedAttempts >= totalAttempts) {
      console.log(`üìä Clear alerts operation completed:`);
      console.log(`   - Total attempts: ${totalAttempts}`);
      console.log(`   - Successfully cleared: ${clearedCount}`);
      console.log(`   - Failed: ${totalAttempts - clearedCount}`);
      
      // Only show error if no servers were cleared AND we had attempts
      if (clearedCount === 0 && totalAttempts > 0) {
        alert("‚ùå Failed to clear alerts from any servers. Check console for details.");
      } else if (clearedCount > 0) {
        alert(`üßπ Successfully cleared alerts from ${clearedCount} server(s).`);
      }
    }
  }

  if (totalAttempts === 0) {
    alert("‚ÑπÔ∏è No servers with critical alerts found.");
  } else {
    console.log(`üîÑ Starting clear alerts operation for ${totalAttempts} server(s)...`);
  }
}

// View Rules functionality
function fetchRulesFromServer(ip, timeoutMs = 3000) {
  return new Promise((resolve, reject) => {
    const ws = new WebSocket(`ws://${ip}:8765`);
    let resolved = false;

    const timeout = setTimeout(() => {
      if (!resolved) {
        resolved = true;
        ws.close();
        reject(new Error(`Timeout fetching rules from ${ip}`));
      }
    }, timeoutMs);

    ws.onopen = () => {
      ws.send(JSON.stringify({ type: "get_rules" }));
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "rule_list" && Array.isArray(data.rules)) {
          clearTimeout(timeout);
          resolved = true;
          resolve(data.rules);
        } else {
          clearTimeout(timeout);
          resolved = true;
          resolve([]);
        }
      } catch {
        clearTimeout(timeout);
        resolved = true;
        resolve([]);
      } finally {
        ws.close();
      }
    };

    ws.onerror = () => {
      if (!resolved) {
        clearTimeout(timeout);
        resolved = true;
        reject(new Error(`WebSocket error from ${ip}`));
      }
    };
  });
}

function displayRules(rules) {
  const container = document.getElementById('rules-container');
  
  if (!rules || rules.length === 0) {
    container.innerHTML = '<div class="no-rules">No rules found</div>';
    return;
  }

  const rulesHtml = rules.map(rule => {
    let ruleType = 'Unknown';
    let details = '';

    if (rule.type === 'add_rule') {
      ruleType = 'EDR Rule';
      details = `
        <div>Match Key: ${rule.match_key || 'N/A'}</div>
        <div>Match Values: ${Array.isArray(rule.match_values) ? rule.match_values.join(', ') : rule.match_values || 'N/A'}</div>
        <div>Tags: ${Array.isArray(rule.tags) ? rule.tags.join(', ') : rule.tags || 'N/A'}</div>
        <div>Risk Level: ${rule.risk_level || 'N/A'}</div>
      `;
    } else if (rule.type === 'add_xdr_rule') {
      ruleType = 'XDR Rule';
      details = `
        <div>Action: ${rule.rule_type || 'N/A'}</div>
        <div>IP: ${rule.value?.ip || 'Any'}</div>
        <div>Port: ${rule.value?.port || 'Any'}</div>
      `;
    } else {
      details = `<div>${JSON.stringify(rule, null, 2)}</div>`;
    }

    return `
      <div class="rule-item">
        <div class="rule-type">${ruleType}</div>
        <div class="rule-details">${details}</div>
      </div>
    `;
  }).join('');

  container.innerHTML = rulesHtml;
}

function refreshRules() {
  const selectedServers = Array.from(document.querySelectorAll(".select-server:checked"));
  
  if (selectedServers.length === 0) {
    alert("Please select at least one server to view rules from.");
    return;
  }

  const container = document.getElementById('rules-container');
  container.innerHTML = '<div class="loading-rules">Loading rules...</div>';

  // Try to fetch rules from the first selected server
  const firstServer = selectedServers[0];
  const ip = firstServer.dataset.ip;

  fetchRulesFromServer(ip, 5000)
    .then(rules => {
      displayRules(rules);
      console.log(`‚úÖ Fetched ${rules.length} rules from ${ip}`);
    })
    .catch(err => {
      console.error(`‚ùå Failed to fetch rules from ${ip}:`, err);
      container.innerHTML = `<div class="no-rules">Failed to load rules: ${err.message}</div>`;
    });
}

function viewAllRules() {
  const allServers = Array.from(document.querySelectorAll(".select-server"));
  const onlineServers = allServers.filter(server => {
    const ip = server.dataset.ip;
    const statusCell = document.getElementById(`status-${ip}`);
    return statusCell && statusCell.textContent.includes("Online");
  });
  
  if (onlineServers.length === 0) {
    alert("No online servers found. Please wait for servers to come online.");
    return;
  }

  const popup = document.getElementById('rules-popup');
  const content = document.getElementById('rules-content');
  content.innerHTML = '<div class="loading-rules">Loading rules from all online servers...</div>';
  popup.style.display = 'block';

  // Fetch rules from all online servers
  const rulePromises = onlineServers.map(server => {
    const ip = server.dataset.ip;
    return fetchRulesFromServer(ip, 5000)
      .then(rules => ({ ip, rules, success: true }))
      .catch(err => ({ ip, rules: [], success: false, error: err.message }));
  });

  Promise.all(rulePromises)
    .then(results => {
      const allRules = [];
      const failedServers = [];
      
      results.forEach(result => {
        if (result.success && result.rules.length > 0) {
          result.rules.forEach(rule => {
            allRules.push({
              ...rule,
              server_ip: result.ip
            });
          });
        } else if (!result.success) {
          failedServers.push(result.ip);
        }
      });

      if (allRules.length === 0) {
        content.innerHTML = '<div class="no-rules">No rules found on any online servers</div>';
        if (failedServers.length > 0) {
          console.warn(`Failed to fetch rules from: ${failedServers.join(', ')}`);
        }
        return;
      }

      // Display all rules grouped by server
      const rulesByServer = {};
      allRules.forEach(rule => {
        if (!rulesByServer[rule.server_ip]) {
          rulesByServer[rule.server_ip] = [];
        }
        rulesByServer[rule.server_ip].push(rule);
      });

      let rulesHtml = '';
      Object.keys(rulesByServer).forEach(ip => {
        const serverRules = rulesByServer[ip];
        rulesHtml += `<div class="rule-item" style="border-left: 4px solid var(--primary); margin-bottom: 1rem;">`;
        rulesHtml += `<div class="rule-type">Server: ${ip} (${serverRules.length} rules)</div>`;
        
        serverRules.forEach(rule => {
          let ruleType = 'Unknown';
          let details = '';

          if (rule.type === 'add_rule') {
            ruleType = 'EDR Rule';
            details = `
              <div>Match Key: ${rule.match_key || 'N/A'}</div>
              <div>Match Values: ${Array.isArray(rule.match_values) ? rule.match_values.join(', ') : rule.match_values || 'N/A'}</div>
              <div>Tags: ${Array.isArray(rule.tags) ? rule.tags.join(', ') : rule.tags || 'N/A'}</div>
              <div>Risk Level: ${rule.risk_level || 'N/A'}</div>
            `;
          } else if (rule.match_key && rule.match_values) {
            // EDR rules without type field but with match_key and match_values
            ruleType = 'EDR Rule';
            details = `
              <div>Match Key: ${rule.match_key || 'N/A'}</div>
              <div>Match Values: ${Array.isArray(rule.match_values) ? rule.match_values.join(', ') : rule.match_values || 'N/A'}</div>
              <div>Tags: ${Array.isArray(rule.tags) ? rule.tags.join(', ') : rule.tags || 'N/A'}</div>
              <div>Risk Level: ${rule.risk_level || 'N/A'}</div>
            `;
          } else if (rule.type === 'add_xdr_rule') {
            ruleType = 'XDR Rule';
            details = `
              <div>Action: ${rule.rule_type || 'N/A'}</div>
              <div>IP: ${rule.value?.ip || 'Any'}</div>
              <div>Port: ${rule.value?.port || 'Any'}</div>
            `;
          } else {
            details = `<div>${JSON.stringify(rule, null, 2)}</div>`;
          }

          rulesHtml += `
            <div class="rule-item" style="margin-left: 1rem; margin-top: 0.5rem;">
              <div class="rule-type">${ruleType}</div>
              <div class="rule-details">${details}</div>
            </div>
          `;
        });
        
        rulesHtml += `</div>`;
      });

      content.innerHTML = rulesHtml;
      console.log(`‚úÖ Fetched ${allRules.length} total rules from ${Object.keys(rulesByServer).length} servers`);
      
      if (failedServers.length > 0) {
        console.warn(`‚ùå Failed to fetch rules from: ${failedServers.join(', ')}`);
      }
    })
    .catch(err => {
      console.error(`‚ùå Failed to fetch rules:`, err);
      content.innerHTML = `<div class="no-rules">Failed to load rules: ${err.message}</div>`;
    });
}

function deleteAllRules() {
  const allServers = Array.from(document.querySelectorAll(".select-server"));
  const onlineServers = allServers.filter(server => {
    const ip = server.dataset.ip;
    const statusCell = document.getElementById(`status-${ip}`);
    return statusCell && statusCell.textContent.includes("Online");
  });

  if (onlineServers.length === 0) {
    alert("No online servers found. Please wait for servers to come online.");
    return;
  }

  const confirmed = confirm("Are you sure you want to delete ALL rules from all online servers? This action cannot be undone.");
  if (!confirmed) return;

  const deletePromises = onlineServers.map(server => {
    const ip = server.dataset.ip;
    return new Promise((resolve, reject) => {
      const ws = new WebSocket(`ws://${ip}:8765`);
      let responseReceived = false;
      let timeoutId = null;

      timeoutId = setTimeout(() => {
        ws.close();
        reject(new Error(`Timeout deleting rules from ${ip}`));
      }, 10000); // 10 second timeout

      ws.onopen = () => {
        ws.send(JSON.stringify({ type: "clear_rules" }));
      };

      ws.onmessage = (event) => {
        responseReceived = true;
        try {
          const data = JSON.parse(event.data);
          if (data.type === "rule_list") {
            clearTimeout(timeoutId);
            resolve({ ip, success: true });
          } else {
            clearTimeout(timeoutId);
            reject(new Error(`Unexpected response type from ${ip}: ${data.type}`));
          }
        } catch (err) {
          clearTimeout(timeoutId);
          reject(err);
        }
      };

      ws.onerror = (err) => {
        clearTimeout(timeoutId);
        reject(err);
      };

      ws.onclose = (event) => {
        if (!responseReceived) {
          clearTimeout(timeoutId);
          reject(new Error(`WebSocket closed for ${ip} before response`));
        }
      };
    });
  });

  Promise.all(deletePromises)
    .then(results => {
      const successfulDeletes = results.filter(r => r.success).length;
      const failedDeletes = results.filter(r => !r.success).length;

      if (successfulDeletes === 0) {
        alert("‚ùå Failed to delete rules from any online servers.");
      } else {
        alert(`üßπ Successfully deleted rules from ${successfulDeletes} server(s).`);
      }
      if (failedDeletes > 0) {
        console.warn(`‚ùå Failed to delete rules from: ${results.filter(r => !r.success).map(r => r.ip).join(', ')}`);
      }
    })
    .catch(err => {
      console.error(`‚ùå Failed to delete rules:`, err);
      alert(`‚ùå Failed to delete rules: ${err.message}`);
    });
}

function viewAllXDRRules() {
  const allServers = Array.from(document.querySelectorAll(".select-server"));
  const onlineServers = allServers.filter(server => {
    const ip = server.dataset.ip;
    const statusCell = document.getElementById(`status-${ip}`);
    return statusCell && statusCell.textContent.includes("Online");
  });
  
  if (onlineServers.length === 0) {
    alert("No online servers found. Please wait for servers to come online.");
    return;
  }

  const popup = document.getElementById('rules-popup');
  const content = document.getElementById('rules-content');
  content.innerHTML = '<div class="loading-rules">Loading network rules from all online servers...</div>';
  popup.style.display = 'block';

  // Fetch network rules from all online servers using get_xdr_rules
  const rulePromises = onlineServers.map(server => {
    const ip = server.dataset.ip;
    return fetchXDRRulesFromServer(ip, 5000)
      .then(rules => ({ ip, rules, success: true }))
      .catch(err => ({ ip, rules: [], success: false, error: err.message }));
  });

  Promise.all(rulePromises)
    .then(results => {
      const allRules = [];
      const failedServers = [];
      
      results.forEach(result => {
        if (result.success && result.rules.length > 0) {
          result.rules.forEach(rule => {
            allRules.push({
              ...rule,
              server_ip: result.ip
            });
          });
        } else if (!result.success) {
          failedServers.push(result.ip);
        }
      });

      if (allRules.length === 0) {
        content.innerHTML = '<div class="no-rules">No network rules found on any online servers</div>';
        if (failedServers.length > 0) {
          console.warn(`Failed to fetch network rules from: ${failedServers.join(', ')}`);
        }
        return;
      }

      // Display all network rules grouped by server
      const rulesByServer = {};
      allRules.forEach(rule => {
        if (!rulesByServer[rule.server_ip]) {
          rulesByServer[rule.server_ip] = [];
        }
        rulesByServer[rule.server_ip].push(rule);
      });

      let rulesHtml = '';
      Object.keys(rulesByServer).forEach(ip => {
        const serverRules = rulesByServer[ip];
        rulesHtml += `<div class="rule-item" style="border-left: 4px solid var(--primary); margin-bottom: 1rem;">`;
        rulesHtml += `<div class="rule-type">Server: ${ip} (${serverRules.length} network rules)</div>`;
        
        serverRules.forEach(rule => {
          let ruleType = 'Unknown';
          let details = '';

          if (rule.type === 'add_xdr_rule') {
            ruleType = 'XDR Rule';
            details = `
              <div>Action: ${rule.rule_type || 'N/A'}</div>
              <div>IP: ${rule.value?.ip || 'Any'}</div>
              <div>Port: ${rule.value?.port || 'Any'}</div>
            `;
          } else if (rule.type === 'block') {
            ruleType = 'XDR Block Rule';
            details = `
              <div>Action: Block</div>
              <div>IP: ${rule.value?.ip || 'Any'}</div>
              <div>Port: ${rule.value?.port || 'Any'}</div>
            `;
          } else if (rule.type === 'allow') {
            ruleType = 'XDR Allow Rule';
            details = `
              <div>Action: Allow</div>
              <div>IP: ${rule.value?.ip || 'Any'}</div>
              <div>Port: ${rule.value?.port || 'Any'}</div>
            `;
          } else {
            ruleType = 'XDR Rule';
            details = `
              <div>Type: ${rule.type || 'Unknown'}</div>
              <div>IP: ${rule.value?.ip || 'Any'}</div>
              <div>Port: ${rule.value?.port || 'Any'}</div>
            `;
          }

          rulesHtml += `
            <div class="rule-item" style="margin-left: 1rem; margin-top: 0.5rem;">
              <div class="rule-type">${ruleType}</div>
              <div class="rule-details">${details}</div>
            </div>
          `;
        });
        
        rulesHtml += `</div>`;
      });

      content.innerHTML = rulesHtml;
      console.log(`‚úÖ Fetched ${allRules.length} total network rules from ${Object.keys(rulesByServer).length} servers`);
      
      if (failedServers.length > 0) {
        console.warn(`‚ùå Failed to fetch network rules from: ${failedServers.join(', ')}`);
      }
    })
    .catch(err => {
      console.error(`‚ùå Failed to fetch network rules:`, err);
      content.innerHTML = `<div class="no-rules">Failed to load network rules: ${err.message}</div>`;
    });
}

// New function to fetch XDR rules from server
function fetchXDRRulesFromServer(ip, timeoutMs = 3000) {
  return new Promise((resolve, reject) => {
    const ws = new WebSocket(`ws://${ip}:8765`);
    let resolved = false;

    const timeout = setTimeout(() => {
      if (!resolved) {
        resolved = true;
        ws.close();
        reject(new Error(`Timeout fetching XDR rules from ${ip}`));
      }
    }, timeoutMs);

    ws.onopen = () => {
      ws.send(JSON.stringify({ type: "get_xdr_rules" }));
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "xdr_rule_list" && Array.isArray(data.rules)) {
          clearTimeout(timeout);
          resolved = true;
          resolve(data.rules);
        } else {
          clearTimeout(timeout);
          resolved = true;
          resolve([]);
        }
      } catch {
        clearTimeout(timeout);
        resolved = true;
        resolve([]);
      } finally {
        ws.close();
      }
    };

    ws.onerror = () => {
      if (!resolved) {
        clearTimeout(timeout);
        resolved = true;
        reject(new Error(`WebSocket error from ${ip}`));
      }
    };
  });
}

function deleteAllXDRRules() {
  const allServers = Array.from(document.querySelectorAll(".select-server"));
  const onlineServers = allServers.filter(server => {
    const ip = server.dataset.ip;
    const statusCell = document.getElementById(`status-${ip}`);
    return statusCell && statusCell.textContent.includes("Online");
  });

  if (onlineServers.length === 0) {
    alert("No online servers found. Please wait for servers to come online.");
    return;
  }

  const confirmed = confirm("Are you sure you want to delete ALL network rules from all online servers? This action cannot be undone.");
  if (!confirmed) return;

  const totalAttempts = onlineServers.length;
  const deletePromises = onlineServers.map(server => {
    const ip = server.dataset.ip;
    return new Promise((resolve, reject) => {
      const ws = new WebSocket(`ws://${ip}:8765`);
      let responseReceived = false;
      let timeoutId = null;

      timeoutId = setTimeout(() => {
        ws.close();
        reject(new Error(`Timeout deleting network rules from ${ip}`));
      }, 15000); // Increased to 15 second timeout

      ws.onopen = () => {
        ws.send(JSON.stringify({ type: "clear_xdr_rules" }));
      };

      ws.onmessage = (event) => {
        responseReceived = true;
        console.log(`üì• Raw response from ${ip}:`, event.data);
        try {
          const data = JSON.parse(event.data);
          console.log(`üìã Parsed response from ${ip}:`, data);
          console.log(`üìã Response type:`, data.type);
          console.log(`üìã Has type field:`, 'type' in data);
          
          // Filter out alert/event messages that don't have a type field
          if (!('type' in data)) {
            console.log(`üìã Ignoring alert/event message from ${ip}, waiting for actual response...`);
            return; // Don't resolve/reject, keep waiting for the actual response
          }
          
          if (data.type === "xdr_rule_list") {
            clearTimeout(timeoutId);
            console.log(`‚úÖ Successfully received xdr_rule_list from ${ip}`);
            resolve({ ip, success: true });
          } else if (data.type) {
            clearTimeout(timeoutId);
            console.warn(`‚ö†Ô∏è Unexpected response type from ${ip}:`, data.type);
            reject(new Error(`Unexpected response type from ${ip}: ${data.type}`));
          } else {
            clearTimeout(timeoutId);
            console.warn(`‚ö†Ô∏è Response has no type field from ${ip}:`, data);
            reject(new Error(`Response has no type field from ${ip}`));
          }
        } catch (err) {
          clearTimeout(timeoutId);
          console.error(`‚ùå Parse error from ${ip}:`, err);
          reject(err);
        }
        
        // Add a small delay before closing to ensure response is processed
        setTimeout(() => {
          ws.close();
        }, 100);
      };

      ws.onerror = (err) => {
        clearTimeout(timeoutId);
        reject(err);
      };

      ws.onclose = (event) => {
        if (!responseReceived) {
          clearTimeout(timeoutId);
          reject(new Error(`WebSocket closed for ${ip} before response`));
        }
      };
    });
  });

  Promise.all(deletePromises)
    .then(results => {
      const successfulDeletes = results.filter(r => r.success).length;
      const failedDeletes = results.filter(r => !r.success).length;

      if (successfulDeletes === 0 && totalAttempts > 1) {
        alert("‚ùå Failed to delete network rules from any online servers.");
      } else if (successfulDeletes > 0) {
        alert(`üßπ Successfully deleted network rules from ${successfulDeletes} server(s).`);
      }
      if (failedDeletes > 0) {
        console.warn(`‚ùå Failed to delete network rules from: ${results.filter(r => !r.success).map(r => r.ip).join(', ')}`);
      }
    })
    .catch(err => {
      console.error(`‚ùå Failed to delete network rules:`, err);
      alert(`‚ùå Failed to delete network rules: ${err.message}`);
    });
}

// Auto-refresh rules when servers are selected/deselected
function setupRulesRefresh() {
  document.addEventListener('change', (event) => {
    if (event.target.classList.contains('select-server')) {
      const selectedServers = document.querySelectorAll(".select-server:checked");
      if (selectedServers.length > 0) {
        // Debounce the refresh to avoid too many requests
        clearTimeout(window.rulesRefreshTimeout);
        window.rulesRefreshTimeout = setTimeout(refreshRules, 500);
      }
    }
  });
}

// Initialize rules refresh functionality
document.addEventListener('DOMContentLoaded', function() {
  setupRulesRefresh();
});

function showAlertsPopup(ip) {
  const ws = new WebSocket(`ws://${ip}:8765`);

  ws.onopen = () => {
    ws.send(JSON.stringify({ type: "get_alerts" }));
  };

  ws.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);

      if (data.type === "alert_list" && Array.isArray(data.alerts)) {
        const popup = document.getElementById('rules-popup');
        const content = document.getElementById('rules-content');
        
        if (data.alerts.length === 0) {
          content.innerHTML = `<div class="no-rules">No alerts found for server ${ip}</div>`;
        } else {
          let alertsHtml = `<div class="rule-item" style="border-left: 4px solid #f39c12; margin-bottom: 1rem;">`;
          alertsHtml += `<div class="rule-type">Server: ${ip} (${data.alerts.length} alerts)</div>`;
          
          data.alerts.forEach(alert => {
            const timestamp = alert.time || alert.timestamp || 'Unknown time';
            const message = alert.message || alert.msg || 'Unknown event';
            const risk = alert.risk_level || alert.severity || 'unknown';
            const riskBullet = getRiskBullet(risk);
            
            alertsHtml += `
              <div class="rule-item" style="margin-left: 1rem; margin-top: 0.5rem; border-left: 2px solid ${risk === 'critical' || risk === 'high' || risk === 1 ? '#e74c3c' : risk === 'medium' || risk === 2 ? '#f39c12' : '#27ae60'};">
                <div class="rule-type">${riskBullet} ${timestamp}</div>
                <div class="rule-details">${message}</div>
              </div>
            `;
          });
          
          alertsHtml += `</div>`;
          content.innerHTML = alertsHtml;
        }
        
        popup.style.display = 'block';
        // Change the popup title to reflect that we're showing alerts
        const title = popup.querySelector('h3');
        title.textContent = 'üö® Server Alerts';
      }
    } catch (err) {
      console.error("WebSocket alert fetch error:", err);
      const popup = document.getElementById('rules-popup');
      const content = document.getElementById('rules-content');
      content.innerHTML = `<div class="no-rules">Failed to load alerts: ${err.message}</div>`;
      popup.style.display = 'block';
    } finally {
      ws.close();
    }
  };

  ws.onerror = (err) => {
    console.error(`‚ùå WebSocket error fetching alerts from ${ip}:`, err);
    const popup = document.getElementById('rules-popup');
    const content = document.getElementById('rules-content');
    content.innerHTML = `<div class="no-rules">Failed to connect to server ${ip}</div>`;
    popup.style.display = 'block';
  };
}

function closeRulesPopup() {
  const popup = document.getElementById('rules-popup');
  const title = popup.querySelector('h3');
  title.textContent = 'üß† All Rules';
  popup.style.display = 'none';
}

</script>

</body>
</html>
